<!DOCTYPE html>
<html>
<head>
  <title>Tema 07 - Fundamentos Estadísticos</title>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'Tema 07 - Fundamentos Estadísticos',
                        useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                        favIcon: 'Tema07sl_files/logo.svg',
              },

      // Author information
      presenters: [
            {
        name:  'Prof.: Pedro Albarrán' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            {
        name:  'Prof.: Alberto Pérez' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <link href="site_libs/ioslides-13.5.1/fonts/fonts.css" rel="stylesheet" />
  <link href="site_libs/ioslides-13.5.1/theme/css/default.css" rel="stylesheet" />
  <link href="site_libs/ioslides-13.5.1/theme/css/phone.css" rel="stylesheet" />
  <script src="site_libs/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/prettify/prettify.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/prettify/lang-r.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/hammer.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/slide-controller.js"></script>
  <script src="site_libs/ioslides-13.5.1/js/slide-deck.js"></script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    summary {
      display: list-item;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }
/* https://github.com/ropensci/plotly/pull/524#issuecomment-468142578 */
slide:not(.current) .plotly.html-widget{
  display: block;
}

    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
            code.sourceCode > span { display: inline-block; line-height: 1.25; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode { white-space: pre; position: relative; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    code.sourceCode { white-space: pre-wrap; }
    code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
        
    slides > slide:not(.nobackground):before {
      font-size: 12pt;
      content: "";
      position: absolute;
      bottom: 20px;
      left: 60px;
      background: url(Tema07sl_files/logo.svg) no-repeat 0 50%;
      -webkit-background-size: 30px 30px;
      -moz-background-size: 30px 30px;
      -o-background-size: 30px 30px;
      background-size: 30px 30px;
      padding-left: 40px;
      height: 30px;
      line-height: 1.9;
    }
  </style>


</head>

<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
        <aside class="gdbar"><img src="Tema07sl_files/logo.svg"></aside>
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      
      <p data-config-presenter><!-- populated from slide_config.json --></p>
            <p style="margin-top: 6px; margin-left: -2px;">Universidad de Alicante, Curso 2020/21</p>
          </hgroup>
  </slide>

<slide class=""><hgroup><h2>Fundamentos Estadísticos</h2></hgroup><article  id="fundamentos-estadísticos">

<ul>
<li>Objetivo: extraer información de los datos.</li>
</ul>

<center>

<img src='pic/model.png' title=''/>

</center>

<ul>
<li>Herramientas previas:

<ul>
<li>Limpieza y Transformación</li>
<li>Detectar patrones iniciales</li>
</ul></li>
<li>Métodos estadísticos, incluyendo <strong>modelización</strong>

<ul>
<li>Encontrar patrones complejos, y cuantifificar su fortaleza</li>
<li>Interpretación de datos</li>
</ul></li>
</ul>

<!--

## Métodos estadísticos

 Una técnica estadística ("contraste de la t") es más que una fórmula

+ Supuestos
    - ej. observaciones $X_1,\ldots,X_n$ numéricas de una distribución (normal)

+ Modelos
    - ej.  $X_{i}=\mu + \varepsilon_{i}$

+ Métodos (numéricos) para ajustarse al modelo

+ Hipótesis y situaciones en las que pueden utilizarse los modelos:
     - ej. la media de $X_i$ (desconocida) es $\mu = 0$

+ Métodos (probabilísticos) para cuantificar la incertidumbre en el ajuste del modelo:
     - ej. el intervalo $\overline{X} \pm 1.96 \cdot \frac{\sigma_{X}}{\sqrt{n}}$ contiene el verdadero $\mu$ con prob. 95%

+ Cuantificación de la fuerza de la evidencia a favor (o en contra) de hipótesis
     - ej.  menor valor p (contraste t), mayor evidencia en contra de la hipótesis
-->

</article></slide><slide class=""><hgroup><h2>Muestras y Poblaciones</h2></hgroup><article  id="muestras-y-poblaciones">

<!--
Aunque unos datos concretos son fijos, pero la metodología  estadística se rige por una visión más amplia: los casos observados proceden de un conjunto mucho mayor de casos potenciales. Los datos dados son una *muestra* de una *población* más grande. 
-->

<ul>
<li>Los datos (casos observados) son una <em>muestra</em> de una <em>población</em> mayor (de casos potenciales)</li>
</ul>

<center>

<img width="82%" src='pic/sample-pop2.png' title=''/>

</center>

</article></slide><slide class=""><hgroup><h2>Muestreo de la población</h2></hgroup><article  id="muestreo-de-la-población">

<ul>
<li><p>Sabiendo el retraso medio desde NY a San Francisco (SFO) podemos planificar la antelación con que se toma el vuelo</p></li>
<li><p>Suponemos que la muestra total observada en <code>nycflights13</code> ha salido de una población teórica de una distribución lognormal:</p></li>
</ul>

<pre class = 'prettyprint lang-r'>library(nycflights13)
SF &lt;- flights %&gt;%
  filter(dest == &quot;SFO&quot;, !is.na(arr_delay))

SF %&gt;%  
  ggplot() + geom_histogram(aes(x=arr_delay, y=..density..)) +
             geom_line(aes(x=arr_delay, y = dlnorm(SF$arr_delay+87, 4.403,0.409)))
SF %&gt;% describe(arr_delay) %&gt;% select(mean,sd, p00,p25,p50,p75,p100)</pre>

</article></slide><slide class=""><hgroup><h2>Decisiones basadas en datos observados</h2></hgroup><article  id="decisiones-basadas-en-datos-observados">

<ul>
<li>Imaginad que NO disponemos de los datos de <code>nycflights13</code> sino solo una muestra de información con los últimos \(n = 25\) vuelos</li>
</ul>

<pre class = 'prettyprint lang-r'>set.seed(501) # set.seed(501)  set.seed(1001) 
datos1 &lt;- tibble(x=(rlnorm(n = 25, meanlog = 4.403, sdlog = 0.409)-87))
datos1 %&gt;% ggplot() + geom_histogram(aes(x=x, y=..density..))
datos1 %&gt;% describe() %&gt;% select(mean, sd, p00, p25, p50, p75, p100)</pre>

<!--
- `set.seed()` para especificar cómo imitar la selección aleatoria mediante *generador pseudo-aleatorio*.
-->

<!--
* Regla: tomar el avión con una antelación igual al máximo observado


```r
SF %>% 
  summarize(prop.late1 = mean(arr_delay > 48), prop.late2 =mean(arr_delay > 113))
```




## Decisiones basadas en datos observados (cont.)

-->

<ul>
<li>Regla: bajo normalidad, sólo el 2,27% se retrasan más que \(\mu + 2\sigma\)</li>
</ul>

<pre class = 'prettyprint lang-r'>list((5.311 + 2 * 24.780) + 87, 
     (7.933 + 2 *   43.943) + 87) %&gt;%  
  map_dbl(plnorm, meanlog = 4.403, sdlog = 0.409, lower.tail = FALSE)</pre>

<ol>
<li>¿Era el supuesto apropiado?</li>
<li>Condicionamientos a día, hora, aerolínea</li>
<li>¿Qué sabemos sobre la incertidumbre en la estimación de \(\mu\) y \(\sigma\)?</li>
</ol>

</article></slide><slide class=""><hgroup><h2>Incertidumbre por la distribución del muestreo</h2></hgroup><article  id="incertidumbre-por-la-distribución-del-muestreo">

<ul>
<li>¿Cómo de fiable es un estadístico muestral? Simulemos la distribución de la media en muchas muestras todas de tamaño \(n=25\)</li>
</ul>

<pre class = 'prettyprint lang-r'>Muestras &lt;- list()
set.seed(101)
for(i in 1:100){
  Muestras[[i]] &lt;- tibble(x = rlnorm(n = 25, meanlog = 4.403, sdlog = 0.409) - 87)  %&gt;% 
        summarize(media = mean(x), sd = sd(x))
}
Muestras %&gt;% bind_rows() %&gt;% head(10)</pre>

<ul>
<li><p>Existe una gran variabilidad del estadístico muestral: es poco fiable</p></li>
<li><p>En una situación realista (solo tenemos UNA MUESTRA), ¿es posible <strong>cuantificar la incertidumbre</strong>?</p></li>
</ul>

</article></slide><slide class=""><hgroup><h2>Distribuciones muestrales</h2></hgroup><article  id="distribuciones-muestrales">

<ul>
<li><p>Un <em>estadístico</em> es un valor calculado a partir de una muestra (ej., la media)</p></li>
<li><p><strong>Distribución muestral</strong> es la distribución del estadístico en las muestras potenciales de <strong>tamaño muestral \(n\)</strong></p>

<ul>
<li>si conocemos las distribución poblacional que genera las muestras, podemos disponer de muestras y ver cómo varía el valor del estadístico</li>
</ul></li>
</ul>

<!--    + aquí lo hemos aproximado con 100 muestras -->

<pre class = 'prettyprint lang-r'>Muestras %&gt;% bind_rows() %&gt;% ggplot(aes(x=media)) + geom_density()</pre>

<ul>
<li><p>Por supuesto, nos interesan varios aspectos de la distribución muestral como su <em>forma</em> y <em>error estándar</em> (<!--desviación típica (variabilidad)--> variabilidad de la distribución muestral)</p></li>
<li><p>El <em>intervalo de confianza del 95%</em> es otra forma de resumir la distribución muestral</p></li>
</ul>

</article></slide><slide class=""><hgroup><h2>Distribuciones muestrales (cont.)</h2></hgroup><article  id="distribuciones-muestrales-cont.">

<!--
* La fiabilidad de un estadístico muestral se mide  por 

  1. la media del estadístico (media de la distribución muestral): debe estar cerca del verdadero (en la población). 

  2. el error estándar del estadístico (error estándar de la distribución muestral); debe ser pequeño. 
-->

<ul>
<li>¿Cómo cambia la media y el error estándar del estadístico cuando varia el tamaño muestral?</li>
</ul>

<pre class = 'prettyprint lang-r'>Muestras_porN &lt;- list()
nvec &lt;- c(25, 50, 100, 200)
for(j in seq_along(nvec)){
  n &lt;- nvec[j]
  Muestras &lt;- list()   # bucle anterior, generalizando n y conservándolo en summarize
  set.seed(101)
  for(i in 1:100){
    Muestras[[i]] &lt;- tibble(x = rlnorm(n = n, meanlog = 4.403, sdlog = 0.409) - 87)  %&gt;%   
        summarize(media = mean(x), sd = sd(x), n = n)      
  }
  Muestras_porN[[j]] &lt;- Muestras %&gt;% bind_rows()
}
Muestras_Final &lt;- Muestras_porN %&gt;% bind_rows()</pre>

</article></slide><slide class=""><hgroup><h2>Distribuciones muestrales: TCL y LGN</h2></hgroup><article  id="distribuciones-muestrales-tcl-y-lgn">

<ul>
<li>Si <strong>aumentamos el tamaño de la muestra en \(n\), el error estándar disminuirá</strong>.</li>
</ul>

<pre class = 'prettyprint lang-r'>Muestras_Final %&gt;% ggplot(aes(x=media)) + geom_density() + facet_wrap(~n)
Muestras_Final %&gt;% group_by(n) %&gt;% 
  summarize(media_de_media = mean(media), error = sd(media))</pre>

<ul>
<li><p><em>Ley de números grandes</em>: para un tamaño de la muestra \(n\) grande, el promedio de la muestra está cerca de la media de la población <!--, y el error estándar es pequeño. --></p></li>
<li><p><em>Teorema de Límite Central</em>: para un tamaño de la muestra \(n\) grande, la distribución muestral de la media es normal.</p>

<p>\[\mbox{Error estándar}(\bar{X}_n) = \frac{\sigma}{\sqrt{n}},\] donde \(\sigma\) es la desviación estándar de la población.</p></li>
</ul>

</article></slide><slide class=""><hgroup><h2>Procedimiento <em>Bootstrap</em></h2></hgroup><article  id="procedimiento-bootstrap">

<ul>
<li><p>En la práctica, sólo tenemos UNA muestra de tamaño \(n\) (no la población)</p></li>
<li><p><strong>Idea</strong>: pensar en la muestra como si fuera la población</p>

<ul>
<li><p>tomar muchas nuevas muestras (<em>remuestras</em> o muestras de Bootstrap) con reemplazamiento de la muestra original</p></li>
<li><p>en cada remuestra, se puede calcular cualquier estadístico</p></li>
</ul></li>
<li><p>Se obtiene la <strong>distribución muestral bootstrap</strong>: NO es la distribución muestral, pero aproxima sus aspectos principales (ej., <em>error estándar</em>).</p></li>
</ul>

<!--una distribución de valores de los ensayos bootstrap -->

<!-- aproxima para vlaores moderados de n -->

<ul>
<li><p>NOTA: remuestreo con reemplazamiento de \((1,2,3)\): \((1,1,3)\), \((2,3,2)\), etc.</p>

<ul>
<li>con \(n\) grande, poca probilidad de tener la muestra original</li>
<li>(y solo es una combinación de muchas)</li>
</ul></li>
</ul>

<!-- es un método estadístico que nos  permite aproximar la distribución muestral sin acceso a la población.-->

</article></slide><slide class=""><hgroup><h2><em>Bootstrap</em> y la distribución muestral</h2></hgroup><article  id="bootstrap-y-la-distribución-muestral">

<ul>
<li>Procedimiento de bootstrap con \(B = 1000\) a partir de <code>datos1</code></li>
</ul>

<pre class = 'prettyprint lang-r'>n &lt;- nrow(datos1)
boot &lt;- list() 
for(i in 1:1000){
    boot[[i]] &lt;- datos1 %&gt;% 
      sample_n(size = n, replace = TRUE) %&gt;%
      summarize(media = mean(x))
  }
boot_df &lt;- boot %&gt;% bind_rows()</pre>

<!-- 
- `sample_n()`  para seleccion filas de forma *aleatoria* de una tabla,
-->

<pre class = 'prettyprint lang-r'>boot_df %&gt;% ggplot(aes(x = media)) + 
  geom_density() + 
  labs(title = &quot;Distribución Bootstrap de la media de retraso en `datos1`&quot;)</pre>

</article></slide><slide class=""><hgroup><h2><em>Bootstrap</em> y la distribución muestral (cont.)</h2></hgroup><article  id="bootstrap-y-la-distribución-muestral-cont.">

<ul>
<li>La estimación bootstrap del error estándar es la desviación estándar de la distribución bootstrap:</li>
</ul>

<pre class = 'prettyprint lang-r'>sd(boot_df$media)</pre>

<ul>
<li>Aunque podemos obtener un mejor intervalo de confianza basado</li>
</ul>

<pre class = 'prettyprint lang-r'>mean(boot_df$media) + c(-1,1) * 1.96 * sd(boot_df$media)</pre>

<ul>
<li>Podemos obtener directamente los percentiles del intervalo en la distribución muestral bootstrap:</li>
</ul>

<pre class = 'prettyprint lang-r'>c(sort(boot_df$media)[25], sort(boot_df$media)[975])</pre>

<!--
#### Errores estándar Bootstrap para muestras grandes

El siguiente código toma muestras para la población `SF` sólo una vez para cada uno de los tamaños muestrales 25--200, y utiliza la muestra (sin referencia a la población) para estimar el error estándar. 


```r
Trials.bootstrap <-list()
nvec = c(25,50,100,200)
for(j in seq_along(nvec)){
  n <- nvec[j]
  sample_df <- SF %>% sample_n(size = n)
  Trials_n <- list() 
  for(i in 1:1000){
    Trials_n[[i]] <- sample_df %>% 
      sample_n(size = n, replace = TRUE) %>%
      summarize(mean = mean(arr_delay), n = n)
  }
  Trials.bootstrap[[j]] <- bind_rows(Trials_n)
}
bind_rows(Trials.bootstrap) %>% 
  group_by(n) %>% 
  summarize(error = sd(mean))
```

Estas estimaciones del error estándar, calculadas mediante bootstrapping de la muestra, se aproximan bastante el error estándar, calculado a partir de la población. 

En este ejemplo, el estadístico muestral es la media. En la práctica, los estadísticos de interés son más complejos, por ejemplo, la estimación del coeficiente en el modelo de regresión lineal. El procedimiento de bootsrapping se puede aplicar a casi todas las situaciones, para cuantificar la incertidumbre en un estadístico.
--></article></slide>


  <slide class="backdrop"></slide>

</slides>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
